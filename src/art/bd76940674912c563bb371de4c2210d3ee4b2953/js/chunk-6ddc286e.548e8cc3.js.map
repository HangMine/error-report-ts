{"version":3,"sources":["webpack:///./src/example/call-when-shown-example.tsx","webpack:///./src/utils/composables/use-callback-when-last-element-shown.ts"],"names":["cwse","render","self","this","list","map","e","setup","listTmp","value","push","callbackWhenLastElementShown","callback","targetSelectorOrSelector","io","watcher","currentVm","nL","length","$nextTick","targets","$el","querySelectorAll","target","IntersectionObserver","entries","obs","forEach","entry","intersectionRatio","unobserve","root","rootMargin","threshold","observe","immediate","terminate","disconnect","callbackWhenLastElementShownNotCompositionVersion","listName","$watch","children","childElementCount","beforeDestroy","$options","call"],"mappings":"+JAGMA,EAAO,6BAAgB,CAC3BC,OAD2B,WACrB,mBACEC,EAAOC,KACb,eAEKD,EAAKE,KAAKC,KAAI,SAAAC,GAAC,qBAAc,OAAd,MACV,wDADU,CAC8CA,UAIpEC,MAV2B,WAWzB,IAAMC,EAAU,CAAC,GACXJ,EAAO,iBAAII,GASjB,OANA,eAA6BJ,GAAM,WAAK,OAGtC,EAAAA,EAAKK,OAAMC,KAAX,QAAmB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,SAC/C,SAEI,CACLN,WAKS,gB,0KChBT,SAAUO,EACdP,EAAuBQ,EAAoBC,GAE3C,IAAIC,EACAC,EACEC,EAAY,kCAClB,wBAAU,WACRD,EAAU,oBAAM,yBAAMX,QAAN,IAAMA,OAAN,EAAMA,EAAMK,QAAb,yDAAoB,WAAOQ,GAAP,8FAC7BA,GAAMA,EAAGC,QAAUD,EAAGC,OAAS,GADF,uCAEzBF,QAFyB,IAEzBA,OAFyB,EAEzBA,EAAWG,YAFc,OAIS,kBAA7BN,GACHO,EAAUJ,EAAWK,IAAIC,iBAAiBT,GAChDU,EAASH,EAAQA,EAAQF,OAAS,IAElCK,EAASV,EAAyBJ,MAEpCK,EAAK,IAAIU,sBAAqB,SAACC,EAASC,GACtCD,EAAQE,SAAQ,SAAAC,GACVA,EAAMC,kBAAoB,IAAOD,EAAML,SAAWA,IACpDG,EAAII,UAAUF,EAAML,QACpBX,UAGH,CACDmB,KAAM,KACNC,WAAY,kBACZC,UAAW,KAEbnB,EAAGoB,QAAQX,GAtBoB,2CAApB,sDAwBZ,CACDY,WAAW,OAGf,IAAMC,EAAY,WACZrB,GACFA,IAEED,GACFA,EAAGuB,cAIP,OADA,yBAAYD,GACLA,EAGH,SAAUE,EACdC,EAAkB3B,EAAoBC,GAEtC,IAAIC,EAEEE,EAAab,KACnBa,EAAUwB,OAAOD,EAAjB,yDAA2B,WAAOtB,GAAP,8FACrBA,GAAMA,EAAGC,OAAS,GADG,gCAEjBF,EAAUG,YAFO,OAMiB,kBAA7BN,GACHO,EAAUJ,EAAWK,IAAIC,iBAAiBT,GAChDU,EAASH,EAAQA,EAAQF,OAAS,IAGlCK,EAASV,EAAyB4B,SAAS5B,EAAyB6B,kBAAoB,GAE1F5B,EAAK,IAAIU,sBAAqB,SAACC,EAASC,GACtCD,EAAQE,SAAQ,SAAAC,GAEkB,IAA5BA,EAAMC,oBACRH,EAAII,UAAUF,EAAML,QACpBX,UAGH,CACDmB,KAAM,KACNC,WAAY,kBACZC,UAAW,IAEbnB,EAAGoB,QAAQX,GA1BY,2CAA3B,uDALgF,IAkCxEoB,EAAkB3B,EAAU4B,SAA5BD,cACR3B,EAAU4B,SAASD,cAAgB,WAE7B7B,GACFA,EAAGuB,aAEDM,GACFA,EAAcE,KAAK7B,IAKV","file":"js/chunk-6ddc286e.548e8cc3.js","sourcesContent":["import { defineComponent, ref } from '@vue/composition-api';\nimport { callbackWhenLastElementShown } from '@/utils/composables/use-callback-when-last-element-shown';\n\nconst cwse = defineComponent({\n  render() {\n    const self = this as InstanceType<typeof cwse>;\n    return (\n      <ul>\n        {self.list.map(e => <li class='item'\n        style='height: 200px; line-height: 300px; background: #aaa;'>{e}</li>)}\n      </ul>\n    );\n  },\n  setup() {\n    const listTmp = [1] as any[];\n    const list = ref(listTmp);\n    // let count = 0;\n\n    callbackWhenLastElementShown(list, () => {\n      // if (count >= 1) return;\n      // count++;\n      list.value.push(...[2, 3, 4, 5, 6, 7, 8, 9, 10, '\\n']);\n    }, '.item');\n\n    return {\n      list,\n    };\n  },\n});\n\nexport default cwse;\n","import {\n  watch, Ref, getCurrentInstance, onUnmounted, onMounted,\n} from '@vue/composition-api';\nimport Vue from 'vue';\nimport 'intersection-observer';\n\nexport function callbackWhenLastElementShown(\n  list: Ref<any[]|null>, callback: ()=> any, targetSelector: string\n):void;\n\nexport function callbackWhenLastElementShown(\n  list: Ref<any[]|null>, callback: ()=> any, container: Ref<Element>\n):void;\n\nexport function callbackWhenLastElementShown(\n  list: Ref<any[]|null>, callback: ()=> any, targetSelectorOrSelector: string | Ref<Element>,\n) {\n  let io:IntersectionObserver;\n  let watcher: any;\n  const currentVm = getCurrentInstance();\n  onMounted(() => {\n    watcher = watch(() => list?.value, async (nL) => {\n      if (nL && nL.length && nL.length > 0) {\n        await currentVm?.$nextTick();\n        let target: Element;\n        if (typeof targetSelectorOrSelector === 'string') {\n          const targets = currentVm!.$el.querySelectorAll(targetSelectorOrSelector);\n          target = targets[targets.length - 1];\n        } else {\n          target = targetSelectorOrSelector.value;\n        }\n        io = new IntersectionObserver((entries, obs) => {\n          entries.forEach(entry => {\n            if (entry.intersectionRatio > 0.9 && entry.target === target) {\n              obs.unobserve(entry.target);\n              callback();\n            }\n          });\n        }, {\n          root: null,\n          rootMargin: '0px 0px 0px 0px',\n          threshold: 0.9,\n        });\n        io.observe(target);\n      }\n    }, {\n      immediate: true,\n    });\n  });\n  const terminate = () => {\n    if (watcher) {\n      watcher();\n    }\n    if (io) {\n      io.disconnect();\n    }\n  };\n  onUnmounted(terminate);\n  return terminate;\n}\n\nexport function callbackWhenLastElementShownNotCompositionVersion(\n  listName: string, callback: ()=> any, targetSelectorOrSelector: string | Element,\n) {\n  let io:IntersectionObserver;\n  // @ts-ignore\n  const currentVm = (this as InstanceType<typeof Vue>);\n  currentVm.$watch(listName, async (nL) => {\n    if (nL && nL.length > 0) {\n      await currentVm.$nextTick();\n\n      let target;\n\n      if (typeof targetSelectorOrSelector === 'string') {\n        const targets = currentVm!.$el.querySelectorAll(targetSelectorOrSelector);\n        target = targets[targets.length - 1];\n        // console.log(target);\n      } else {\n        target = targetSelectorOrSelector.children[targetSelectorOrSelector.childElementCount - 1];\n      }\n      io = new IntersectionObserver((entries, obs) => {\n        entries.forEach(entry => {\n          // console.log(entry.intersectionRatio);\n          if (entry.intersectionRatio === 1) {\n            obs.unobserve(entry.target);\n            callback();\n          }\n        });\n      }, {\n        root: null,\n        rootMargin: '0px 0px 0px 0px',\n        threshold: 1,\n      });\n      io.observe(target);\n    }\n  });\n  const { beforeDestroy } = currentVm.$options;\n  currentVm.$options.beforeDestroy = function newBeforeDestroy() {\n    // console.log('beforedestroy');\n    if (io) {\n      io.disconnect();\n    }\n    if (beforeDestroy) {\n      beforeDestroy.call(currentVm);\n    }\n  };\n}\n\nexport default callbackWhenLastElementShown;\n"],"sourceRoot":""}