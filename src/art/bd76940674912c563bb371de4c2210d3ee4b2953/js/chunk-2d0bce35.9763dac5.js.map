{"version":3,"sources":["webpack:///./node_modules/qwebchannel/qwebchannel.js"],"names":["QWebChannelMessageTypes","signal","propertyUpdate","init","idle","debug","invokeMethod","connectToSignal","disconnectFromSignal","setProperty","response","QWebChannel","transport","initCallback","send","channel","this","data","JSON","stringify","onmessage","message","parse","type","handleSignal","handleResponse","handlePropertyUpdate","console","error","execCallbacks","execId","exec","callback","Number","MAX_VALUE","MIN_VALUE","hasOwnProperty","id","objects","object","signalEmitted","args","warn","i","signals","properties","objectName","QObject","unwrapProperties","name","webChannel","__id__","__objectSignals__","__propertyCache__","addSignal","signalData","isPropertyNotifySignal","signalName","signalIndex","connect","push","disconnect","idx","indexOf","splice","length","invokeSignalCallbacks","signalArgs","connections","forEach","apply","addMethod","methodData","methodName","methodIdx","arguments","argument","undefined","result","unwrapQObject","bindGetterSetter","propertyInfo","propertyIndex","propertyName","notifySignalData","Object","defineProperty","configurable","get","propertyValue","set","value","valueToSend","Array","ret","objectId","qObject","destroyed","propertyNames","propertyIdx","propertyMap","methods","enums","module","exports"],"mappings":"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","file":"js/chunk-2d0bce35.9763dac5.js","sourcesContent":["/****************************************************************************\n**\n** Copyright (C) 2016 The Qt Company Ltd.\n** Copyright (C) 2016 Klar√§lvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Milian Wolff <milian.wolff@kdab.com>\n** Contact: https://www.qt.io/licensing/\n**\n** This file is part of the QtWebChannel module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see https://www.qt.io/terms-conditions. For further\n** information use the contact form at https://www.qt.io/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 3 as published by the Free Software\n** Foundation and appearing in the file LICENSE.LGPL3 included in the\n** packaging of this file. Please review the following information to\n** ensure the GNU Lesser General Public License version 3 requirements\n** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 2.0 or (at your option) the GNU General\n** Public license version 3 or any later version approved by the KDE Free\n** Qt Foundation. The licenses are as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3\n** included in the packaging of this file. Please review the following\n** information to ensure the GNU General Public License requirements will\n** be met: https://www.gnu.org/licenses/gpl-2.0.html and\n** https://www.gnu.org/licenses/gpl-3.0.html.\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n\"use strict\";\n\nvar QWebChannelMessageTypes = {\n    signal: 1,\n    propertyUpdate: 2,\n    init: 3,\n    idle: 4,\n    debug: 5,\n    invokeMethod: 6,\n    connectToSignal: 7,\n    disconnectFromSignal: 8,\n    setProperty: 9,\n    response: 10,\n};\n\nvar QWebChannel = function(transport, initCallback)\n{\n    if (typeof transport !== \"object\" || typeof transport.send !== \"function\") {\n        console.error(\"The QWebChannel expects a transport object with a send function and onmessage callback property.\" +\n                      \" Given is: transport: \" + typeof(transport) + \", transport.send: \" + typeof(transport.send));\n        return;\n    }\n\n    var channel = this;\n    this.transport = transport;\n\n    this.send = function(data)\n    {\n        if (typeof(data) !== \"string\") {\n            data = JSON.stringify(data);\n        }\n        channel.transport.send(data);\n    }\n\n    this.transport.onmessage = function(message)\n    {\n        var data = message.data;\n        if (typeof data === \"string\") {\n            data = JSON.parse(data);\n        }\n        switch (data.type) {\n            case QWebChannelMessageTypes.signal:\n                channel.handleSignal(data);\n                break;\n            case QWebChannelMessageTypes.response:\n                channel.handleResponse(data);\n                break;\n            case QWebChannelMessageTypes.propertyUpdate:\n                channel.handlePropertyUpdate(data);\n                break;\n            default:\n                console.error(\"invalid message received:\", message.data);\n                break;\n        }\n    }\n\n    this.execCallbacks = {};\n    this.execId = 0;\n    this.exec = function(data, callback)\n    {\n        if (!callback) {\n            // if no callback is given, send directly\n            channel.send(data);\n            return;\n        }\n        if (channel.execId === Number.MAX_VALUE) {\n            // wrap\n            channel.execId = Number.MIN_VALUE;\n        }\n        if (data.hasOwnProperty(\"id\")) {\n            console.error(\"Cannot exec message with property id: \" + JSON.stringify(data));\n            return;\n        }\n        data.id = channel.execId++;\n        channel.execCallbacks[data.id] = callback;\n        channel.send(data);\n    };\n\n    this.objects = {};\n\n    this.handleSignal = function(message)\n    {\n        var object = channel.objects[message.object];\n        if (object) {\n            object.signalEmitted(message.signal, message.args);\n        } else {\n            console.warn(\"Unhandled signal: \" + message.object + \"::\" + message.signal);\n        }\n    }\n\n    this.handleResponse = function(message)\n    {\n        if (!message.hasOwnProperty(\"id\")) {\n            console.error(\"Invalid response message received: \", JSON.stringify(message));\n            return;\n        }\n        channel.execCallbacks[message.id](message.data);\n        delete channel.execCallbacks[message.id];\n    }\n\n    this.handlePropertyUpdate = function(message)\n    {\n        for (var i in message.data) {\n            var data = message.data[i];\n            var object = channel.objects[data.object];\n            if (object) {\n                object.propertyUpdate(data.signals, data.properties);\n            } else {\n                console.warn(\"Unhandled property update: \" + data.object + \"::\" + data.signal);\n            }\n        }\n        channel.exec({type: QWebChannelMessageTypes.idle});\n    }\n\n    this.debug = function(message)\n    {\n        channel.send({type: QWebChannelMessageTypes.debug, data: message});\n    };\n\n    channel.exec({type: QWebChannelMessageTypes.init}, function(data) {\n        for (var objectName in data) {\n            var object = new QObject(objectName, data[objectName], channel);\n        }\n        // now unwrap properties, which might reference other registered objects\n        for (var objectName in channel.objects) {\n            channel.objects[objectName].unwrapProperties();\n        }\n        if (initCallback) {\n            initCallback(channel);\n        }\n        channel.exec({type: QWebChannelMessageTypes.idle});\n    });\n};\n\nfunction QObject(name, data, webChannel)\n{\n    this.__id__ = name;\n    webChannel.objects[name] = this;\n\n    // List of callbacks that get invoked upon signal emission\n    this.__objectSignals__ = {};\n\n    // Cache of all properties, updated when a notify signal is emitted\n    this.__propertyCache__ = {};\n\n    var object = this;\n\n    // ----------------------------------------------------------------------\n\n    this.unwrapQObject = function(response)\n    {\n        if (response instanceof Array) {\n            // support list of objects\n            var ret = new Array(response.length);\n            for (var i = 0; i < response.length; ++i) {\n                ret[i] = object.unwrapQObject(response[i]);\n            }\n            return ret;\n        }\n        if (!response\n            || !response[\"__QObject*__\"]\n            || response.id === undefined) {\n            return response;\n        }\n\n        var objectId = response.id;\n        if (webChannel.objects[objectId])\n            return webChannel.objects[objectId];\n\n        if (!response.data) {\n            console.error(\"Cannot unwrap unknown QObject \" + objectId + \" without data.\");\n            return;\n        }\n\n        var qObject = new QObject( objectId, response.data, webChannel );\n        qObject.destroyed.connect(function() {\n            if (webChannel.objects[objectId] === qObject) {\n                delete webChannel.objects[objectId];\n                // reset the now deleted QObject to an empty {} object\n                // just assigning {} though would not have the desired effect, but the\n                // below also ensures all external references will see the empty map\n                // NOTE: this detour is necessary to workaround QTBUG-40021\n                var propertyNames = [];\n                for (var propertyName in qObject) {\n                    propertyNames.push(propertyName);\n                }\n                for (var idx in propertyNames) {\n                    delete qObject[propertyNames[idx]];\n                }\n            }\n        });\n        // here we are already initialized, and thus must directly unwrap the properties\n        qObject.unwrapProperties();\n        return qObject;\n    }\n\n    this.unwrapProperties = function()\n    {\n        for (var propertyIdx in object.__propertyCache__) {\n            object.__propertyCache__[propertyIdx] = object.unwrapQObject(object.__propertyCache__[propertyIdx]);\n        }\n    }\n\n    function addSignal(signalData, isPropertyNotifySignal)\n    {\n        var signalName = signalData[0];\n        var signalIndex = signalData[1];\n        object[signalName] = {\n            connect: function(callback) {\n                if (typeof(callback) !== \"function\") {\n                    console.error(\"Bad callback given to connect to signal \" + signalName);\n                    return;\n                }\n\n                object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];\n                object.__objectSignals__[signalIndex].push(callback);\n\n                if (!isPropertyNotifySignal && signalName !== \"destroyed\") {\n                    // only required for \"pure\" signals, handled separately for properties in propertyUpdate\n                    // also note that we always get notified about the destroyed signal\n                    webChannel.exec({\n                        type: QWebChannelMessageTypes.connectToSignal,\n                        object: object.__id__,\n                        signal: signalIndex\n                    });\n                }\n            },\n            disconnect: function(callback) {\n                if (typeof(callback) !== \"function\") {\n                    console.error(\"Bad callback given to disconnect from signal \" + signalName);\n                    return;\n                }\n                object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];\n                var idx = object.__objectSignals__[signalIndex].indexOf(callback);\n                if (idx === -1) {\n                    console.error(\"Cannot find connection of signal \" + signalName + \" to \" + callback.name);\n                    return;\n                }\n                object.__objectSignals__[signalIndex].splice(idx, 1);\n                if (!isPropertyNotifySignal && object.__objectSignals__[signalIndex].length === 0) {\n                    // only required for \"pure\" signals, handled separately for properties in propertyUpdate\n                    webChannel.exec({\n                        type: QWebChannelMessageTypes.disconnectFromSignal,\n                        object: object.__id__,\n                        signal: signalIndex\n                    });\n                }\n            }\n        };\n    }\n\n    /**\n     * Invokes all callbacks for the given signalname. Also works for property notify callbacks.\n     */\n    function invokeSignalCallbacks(signalName, signalArgs)\n    {\n        var connections = object.__objectSignals__[signalName];\n        if (connections) {\n            connections.forEach(function(callback) {\n                callback.apply(callback, signalArgs);\n            });\n        }\n    }\n\n    this.propertyUpdate = function(signals, propertyMap)\n    {\n        // update property cache\n        for (var propertyIndex in propertyMap) {\n            var propertyValue = propertyMap[propertyIndex];\n            object.__propertyCache__[propertyIndex] = propertyValue;\n        }\n\n        for (var signalName in signals) {\n            // Invoke all callbacks, as signalEmitted() does not. This ensures the\n            // property cache is updated before the callbacks are invoked.\n            invokeSignalCallbacks(signalName, signals[signalName]);\n        }\n    }\n\n    this.signalEmitted = function(signalName, signalArgs)\n    {\n        invokeSignalCallbacks(signalName, this.unwrapQObject(signalArgs));\n    }\n\n    function addMethod(methodData)\n    {\n        var methodName = methodData[0];\n        var methodIdx = methodData[1];\n        object[methodName] = function() {\n            var args = [];\n            var callback;\n            for (var i = 0; i < arguments.length; ++i) {\n                var argument = arguments[i];\n                if (typeof argument === \"function\")\n                    callback = argument;\n                else if (argument instanceof QObject && webChannel.objects[argument.__id__] !== undefined)\n                    args.push({\n                        \"id\": argument.__id__\n                    });\n                else\n                    args.push(argument);\n            }\n\n            webChannel.exec({\n                \"type\": QWebChannelMessageTypes.invokeMethod,\n                \"object\": object.__id__,\n                \"method\": methodIdx,\n                \"args\": args\n            }, function(response) {\n                if (response !== undefined) {\n                    var result = object.unwrapQObject(response);\n                    if (callback) {\n                        (callback)(result);\n                    }\n                }\n            });\n        };\n    }\n\n    function bindGetterSetter(propertyInfo)\n    {\n        var propertyIndex = propertyInfo[0];\n        var propertyName = propertyInfo[1];\n        var notifySignalData = propertyInfo[2];\n        // initialize property cache with current value\n        // NOTE: if this is an object, it is not directly unwrapped as it might\n        // reference other QObject that we do not know yet\n        object.__propertyCache__[propertyIndex] = propertyInfo[3];\n\n        if (notifySignalData) {\n            if (notifySignalData[0] === 1) {\n                // signal name is optimized away, reconstruct the actual name\n                notifySignalData[0] = propertyName + \"Changed\";\n            }\n            addSignal(notifySignalData, true);\n        }\n\n        Object.defineProperty(object, propertyName, {\n            configurable: true,\n            get: function () {\n                var propertyValue = object.__propertyCache__[propertyIndex];\n                if (propertyValue === undefined) {\n                    // This shouldn't happen\n                    console.warn(\"Undefined value in property cache for property \\\"\" + propertyName + \"\\\" in object \" + object.__id__);\n                }\n\n                return propertyValue;\n            },\n            set: function(value) {\n                if (value === undefined) {\n                    console.warn(\"Property setter for \" + propertyName + \" called with undefined value!\");\n                    return;\n                }\n                object.__propertyCache__[propertyIndex] = value;\n                var valueToSend = value;\n                if (valueToSend instanceof QObject && webChannel.objects[valueToSend.__id__] !== undefined)\n                    valueToSend = { \"id\": valueToSend.__id__ };\n                webChannel.exec({\n                    \"type\": QWebChannelMessageTypes.setProperty,\n                    \"object\": object.__id__,\n                    \"property\": propertyIndex,\n                    \"value\": valueToSend\n                });\n            }\n        });\n\n    }\n\n    // ----------------------------------------------------------------------\n\n    data.methods.forEach(addMethod);\n\n    data.properties.forEach(bindGetterSetter);\n\n    data.signals.forEach(function(signal) { addSignal(signal, false); });\n\n    for (var name in data.enums) {\n        object[name] = data.enums[name];\n    }\n}\n\n//required for use with nodejs\nif (typeof module === 'object') {\n    module.exports = {\n        QWebChannel: QWebChannel\n    };\n}"],"sourceRoot":""}